

## 2017.5.10

* FGM:

    发现图中所有频率高于某个阈值的子图。

* 子图的支持度

    给定图集`G`, 子图'g'在图集'G'上的支持度定义为图集'G'包含g的所有图占'G'的百分比。

    $$s(g) = \frac {\left| {G_i} |g \subseteq sG_i, G_i \subseteq G \right|} {\left| {G} \right|}$$

    ==图的支持度就是图集中包含该图的图的个数！这是论文采用的标准==

* 二段的DFG算法

    1. 锁定频繁子图
        * 通过候选剪枝提升频繁子图发现的准确率

    2. 计算每个子图的noisy support
        * lattic-based noisy support计算方法


* 查分隐私

    通过随机机制，添加一些认真选择的干扰噪声，计算结果对单个记录的改变不敏感。这就是所谓的脱敏！

* i-频繁子图

    i-频繁子图就是含有i条边的频繁子图

* 差分隐私下的i-频繁子图挖掘

    1. naive方法
        1. 利用向下封闭属性找出所有可能的i-频繁子图
        2. 对每个i-子图的支持度添加噪音
        3. 添加了噪音的子图的支持度超过门限就认为是频繁i-子图
        * ==问题：== 噪音与候选子图数量成比例！

    2. exponential方法
        1. 利用向下封闭属性找出所有可能的i-频繁子图
        2. 使用exponential方式筛选i-频繁子图
        * ==问题：== 噪声与选中的子图数目成比例，但是无法明确应该选中多少子图！

    3. DFG方法
        * ==阶段一==
        1. 按升序判定子图是否为频繁子图
        2. 使用二分查找判定i-
           频繁子图的数目
        3. 使用条件exponential方法，利用添加了噪声的子图的支持度剪去那些明显的非频繁子图。

        * ==阶段二：== lattice-based有噪音的支持度计算方法
        1. 构建有向lattice，每个节点$n_g$表示一个子图，如果$n_{g_1}$可以扩展到$n_{g_2}$，则在添加一条从
           $n_{g_1}$ 到$n_{g_2}$的有向边。
        2. error-aware的path生成算法，生成path集合，作为计数累积法的输入。 
        3. 计数累积法计算子图的带噪声的支持度

* 近邻数据库

    当前仅当两个数据库至多只有一个输入图不同（一个数据库通过增加或删除一条记录就成了另一个数据库！）

* $\epsilon$-差分隐私标准

    ==不懂啊！！！！==
    ​    

* $\epsilon$-差分隐私的naive方法

    * 使用Laplace算法为所有可能的频繁子图加噪声。
    * 比较支持度和门限进行判定
    * 通过`i-1`子图产生所有可能的`i`子图，作为候选`i`子图
    * 对候选`i`子图加入噪声，计算支持度并和门限值比较。
    * ==问题：== 加入的噪声和候选子图数目成比例，噪声太多！

* DFM详细步骤

    * $\mathbf{FI}_1$

        * 步骤：
            对于大小为$i \subseteq [1, M_g]$的图：
            1. 根据`i-1`子图生成`i`候选子图集合，当`i = 1`时，枚举所有可能的边作候选为`1`-子图，总计$V^2$个候选`1`-子图。
            2. 使用二元函数估计`i`-频繁子图的数目$n_i$
            3. 使用条件exponential方法，从候选子图中选出$n_i$个频繁子图。

        * 二元预测法

            * 利用二分查找方法减少添加的噪音。
            * 确定频繁子图的数目

        * 条件exponential机制

            * 确保添加的噪音是和选中的频繁子图数目成比例
            * 从候选的频繁子图中选取真正的频繁子图

    * $\mathbf{NC}_2$

        * 核心思想：

            利用已经发现的频繁子图的包含关系减少噪音。

        * 步骤：
            1. 使用error-aware path构建方法构建一个path集合，这个集合可以覆盖所有的频繁子图。

            2. 利用计数累计方法计算每个lattice中path集合中所有path上的所有子图的noisy支持度。

        * 计数累计算法

            * 可以确保$\epsilon$-差分隐私！
            1. 利用path上的图的包含关系将数据库分离成多个相互绝缘的子数据库


---

## 2017.5.16

1. 工程构建出问题

    重新导入工程，Intelij Idea会自动添加相应的设置。

2. standard文件不存在

    standard文件需要运行FSG类来生成！而且FSG和DFG的threshold要一致，可以多设置几个threshold先跑FSG，然后再跑对应的DFG。

3. 多踩坑


## 2017.5.17

1. 代码跑通了之后干点啥呢？

    ==不知道，就很迷！==

2. 就在我很迷的时候，祥哥找了我

    所以现在最紧要的任务是把下面的 两个问题弄明白就好了！

    1. ==算法的复杂度分析==
    2. 节点在多个路径上出现的


