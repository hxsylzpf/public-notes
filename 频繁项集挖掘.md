## 基本概念

* 记录

    即数据库中的一条记录，如`bread milk beer`

* 字母表

    即数据库中所有记录所涉及的全部物品的集合

* 项集

    即字母表中的一个子集，项集中的一个项就是一个物品。

* 项集的支持度

    数据库中包含该项集的记录的条数（绝对）或比例（相对）

## 核心方法

1. 对任意子网格`S`广度优先遍历，得到节点访问序
   $$\left\{  n_0, n_1, \cdots, n_{\left| S \right| - 1} \right\}$$
   而且这些这点代表的项集分别为：
   $$\left \{  X_0, X_1, \cdots, X_{\left| S\right| - 1} \right \}$$

2. 将输入数据集`D`切分为$\left | S \right | + 1$个互不相交子数据集。

3. 计算每个频繁项集的支持度
   $$\left | D_i \right| + \sum_{j=1}^{\left| A_i \right|}\left|D_i^j \right| $$
   其中$\left | D_i \right |$表示$X_i$对应的子数据集$D_i$中记录的条数，$D_i^j$为$n_i$
   的前驱节点$a_i^j$所对应的子数据集$D_i^j$的记录的数量。

4. 在计算$\left | D_i \right|$时加入拉普拉斯噪音$Lap(1/ \epsilon_k)$

通过上述方法可以算出每个频繁项集的噪音支持度$ns$

==这种通过广度优先遍历所有sub lattice计算模式的噪音支持度的方法，比先查找path，再通过path计算模式的噪音支持度的方法要好一些，时间复杂度更低。==


## 急需解决的问题

1. 为什么基于sub lattice方法可以在频繁项集发掘中用，却不能再频繁序列和频繁子图中用？

    ==这是因为相同layer之间要求不重复，但是频繁序列和频繁子图都不满足这个条件==

2. 基于sub lattice的方法在加入的噪音规模上会不会比基于path的方法好？为什么？？
    
    ==这个要考实验结果来说明，实验结果表明不如基于path的方法==

    以下实验结果使用pumsb_star数据集，threshold为0.54
    
    * 基于sub-lattice，使用directional exp机制模型的结果：
    ```bash
    0.8756756756756756     #F-Score
    0.005720076814234875   # RE
    ```
    
    * 基于sub-lattice, 使用conditional exp机制模型的结果：
    ```bash
    0.9086021505376344     #F-Score
    0.005659245332246735   #RE
    ```
    
    * 基于path, 使用conditional exp机制模型的结果：
    ```bash
    0.8657534246575342     #F-Score
    0.007296118753454481   #RE
    ```
    
    * 基于path，是使用directional exp机制模型的结果：
    ```bash
    0.8787061994609164     #F-Score
    0.0073966198329018     #RE
    ```
    


## 2017.6.23
* 急需解决的事情：

     在两个实验数据集上跑基于path和基于sub lattice方法的模型，
     得到结果，用excel画图，下周给祥哥。

1. BMS-POS数据集上的对比结果

| 方法 | threshold | F-Score | RE |  
| :-----: | :-----: | :-----: | :-----: |  
|  sublattice   | 0.025    | 0.8679245283018868 | 0.005250668298526485 |
|   path        | 0.025    | 0.8494623655913978 | 0.008351363247662684 |
|  sublattice   | 0.03     | 0.9402985074626865 | 0.0038910357339899714 |
|   path        | 0.03     | 0.9737827715355805 | 0.004456051637848189 |
|  sublattice   | 0.035    | 0.9651741293532338 | 0.0018954622582718498 |
|   path        | 0.035    | 0.9801980198019802 | 0.0024158483403154698 |
|  sublattice   | 0.04     | 0.9629629629629629 | 0.0014283319194720778 |
|   path        | 0.04     | 0.9937888198757764 | 0.0016030819628541314 |
|  sublattice   | 0.045    | 0.9784172661870504 | 0.001936220162024234 |
|   path        | 0.045    | 0.9784172661870504 | 0.0014648429394389908 |


2. pumsb_star数据集上的对比结果

| 方法 | threshold | F-Score | RE |  
| :-----: | :-----: | :-----: | :-----: |  
|  sublattice   | 0.54    | 0.6564299424184262 | 9.632514775264141E-4 |
|   path        | 0.54    | 0.6392156862745099 | 0.0041769256652903685 |
|  sublattice   | 0.58    | 0.8388888888888889 | 4.4994725448211905E-4 |
|   path        | 0.58    | 0.8672086720867209 | 0.003686550834875338 |
|  sublattice   | 0.62    | 0.9103448275862068 | 6.11246639759383E-4 |
|   path        | 0.62    | 0.8771929824561403 | 0.00301783677295741 |
|  sublattice   | 0.66    | 0.7628865979381443 | 2.4058717186772836E-4 |
|   path        | 0.66    | 0.9666666666666667 | 0.0015530882187375574 |
|  sublattice   | 0.7     | 0.9473684210526316 | 2.2678168468387148E-4 |
|   path        | 0.7     | 0.9090909090909091 | 5.406015612484076E-4 |


##2017.6.26

1. 基于sub-lattice的方法在算法复杂度上比基于path的方法没有优势！


